# PredictEdge: Permanent Performance Rules

## üö® CRITICAL: Performance Anti-Patterns to NEVER Use

### 1. **N+1 Queries - FORBIDDEN** ‚ùå
```python
# ‚ùå NEVER DO THIS - Individual queries in loop
for market in markets:
    prediction = await db.execute(select(Prediction).where(...))  # N queries!

# ‚úÖ ALWAYS DO THIS - Single query with JOIN/subquery
latest_preds = await db.execute(
    select(Prediction).join(subquery, ...)  # 1 query!
)
predictions_dict = {p.market_id: p for p in latest_preds}
```

### 2. **Sequential API Calls - FORBIDDEN** ‚ùå
```javascript
// ‚ùå NEVER DO THIS - Sequential awaits
const markets = await fetch('/markets');
const predictions = await fetch('/predictions');  // Waits for markets first

// ‚úÖ ALWAYS DO THIS - Parallel Promise.all()
const [markets, predictions] = await Promise.all([
    fetch('/markets'),
    fetch('/predictions')
]);
```

### 3. **No Caching - FORBIDDEN** ‚ùå
```javascript
// ‚ùå NEVER DO THIS - Always hits API
const data = await fetch('/markets');  // Every time!

// ‚úÖ ALWAYS DO THIS - Use DataCache
const data = await cachedFetch('/markets', {}, params);  // Cached!
```

### 4. **Large Default Limits - FORBIDDEN** ‚ùå
```python
# ‚ùå NEVER DO THIS - Large defaults
limit: int = Query(default=100)  # Too much data!

# ‚úÖ ALWAYS DO THIS - Reasonable defaults
limit: int = Query(default=20, ge=1, le=100)  # Capped!
```

---

## ‚úÖ MANDATORY Performance Patterns

### Pattern 1: Always Use JOINs/Subqueries (Backend)
```python
# When fetching related data, use JOIN/subquery
# Example: Get latest prediction per market

# Step 1: Create subquery for latest time per market
latest_times = (
    select(Prediction.market_id, func.max(Prediction.prediction_time))
    .group_by(Prediction.market_id)
    .subquery()
)

# Step 2: JOIN to get actual predictions
predictions = await db.execute(
    select(Prediction).join(latest_times, ...)
)

# Step 3: Build dict for O(1) lookup
predictions_dict = {p.market_id: p for p in predictions}
```

### Pattern 2: Always Use Parallel Fetching (Frontend)
```javascript
// Fetch multiple endpoints in parallel
const [data1, data2, data3] = await Promise.all([
    cachedFetch('/endpoint1'),
    cachedFetch('/endpoint2'),
    cachedFetch('/endpoint3')
]);
```

### Pattern 3: Always Use Caching (Frontend)
```javascript
// Use DataCache for all API calls
const data = await cachedFetch(endpoint, options, params);

// Cache durations:
// - Markets: 30s
// - Predictions/Signals/Trades: 60s
// - Portfolio: 5min
// - Dashboard: 30s
```

### Pattern 4: Always Set Reasonable Limits
```python
# Backend: Cap limits, set reasonable defaults
limit: int = Query(default=20, ge=1, le=100)

# Frontend: Request reasonable amounts
const data = await cachedFetch('/markets?limit=20');
```

---

## üìä Performance Budgets (HARD LIMITS)

### API Response Time Budgets:
- **Critical Endpoints** (health, dashboard): **< 500ms**
- **List Endpoints** (markets, predictions): **< 1000ms**
- **Detail Endpoints** (single item): **< 500ms**
- **Aggregation Endpoints** (stats, analytics): **< 2000ms**

### Frontend Load Time Budgets:
- **Initial Page Load**: **< 3s**
- **Tab Switch (Cached)**: **< 500ms**
- **Tab Switch (Cold)**: **< 2000ms**

### Database Query Budgets:
- **Single Query**: **< 200ms**
- **Complex Query**: **< 500ms**
- **Total per Endpoint**: **< 1000ms**

---

## üîç Code Review Checklist

Before merging ANY PR, verify:

- [ ] **No N+1 Queries** - Use JOINs/subqueries for related data
- [ ] **No Sequential Awaits** - Use Promise.all() for parallel calls
- [ ] **Caching Used** - All frontend API calls use cachedFetch()
- [ ] **Reasonable Limits** - Default limit ‚â§ 20, max ‚â§ 100
- [ ] **Database Indexes** - Queries use indexed columns
- [ ] **Error Handling** - Timeouts and errors handled gracefully
- [ ] **Performance Test Passed** - Run `./test_performance.sh` before merge

---

## üß™ Mandatory Performance Tests

### Pre-Deployment Checklist:
```bash
# 1. Run performance tests
./test_performance.sh

# 2. Verify all endpoints < 2000ms
# 3. Check for N+1 queries in backend
# 4. Verify frontend caching is used
# 5. Test tab switching performance
```

### Automated Testing:
- Add performance tests to CI/CD pipeline
- Fail builds if endpoints exceed budget
- Monitor production performance metrics

---

## üìö Performance Resources

### Backend Optimization:
- Use SQLAlchemy JOINs, not loops
- Index frequently queried columns
- Use `joinedload()` for relationships
- Batch database operations

### Frontend Optimization:
- Always use `cachedFetch()` wrapper
- Implement parallel fetching with `Promise.all()`
- Set appropriate cache TTLs
- Minimize data transfer (reasonable limits)

---

## üö® Emergency Performance Protocol

If performance degrades:

1. **Run Performance Test**: `./test_performance.sh`
2. **Check Database Queries**: Look for N+1 patterns
3. **Check Frontend**: Verify caching is used
4. **Check Limits**: Ensure reasonable defaults
5. **Review Recent Changes**: Check last 5 commits
6. **Fix Immediately**: Don't deploy slow code

---

## üìù Performance Monitoring

### Metrics to Track:
- API response times (per endpoint)
- Database query times
- Frontend load times
- Cache hit rates
- Error rates

### Alerts:
- Response time > 2000ms
- Database query > 500ms
- Cache hit rate < 50%
- Error rate > 1%

---

**REMEMBER**: Performance is not optional. It's a requirement.  
**RULE**: If it's slow, it's broken. Fix it before deploying.

